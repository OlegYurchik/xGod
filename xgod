#!/bin/bash

# Identify distribution
function XG_getDistributionName()
{
	XG_out=$(lsb_release -i | sed "s/Distributor\ ID:\	//g")
	return 0
}

# Function for add target
function XG_addtarget()
{
	# Check target argument
	if [[ "$1" =~ ^($XG_extensionslist)_([[:graph:]]+)$ ]]; then
		XG_extension=${BASH_REMATCH[1]}
		XG_target=${BASH_REMATCH[2]}
	else
		return 1
	fi
	if [[ -z "${XG_TARGETS[$1]}" ]]; then
		echo -e $XG_C_ERROR$XG_C_RED$XG_C_BOLD"Нет цели '$XG_target'"#C_END
		exit
	fi
	# Check if the target already checked
	for XG_t in ${XG_ALREADYCHECKED[@]}
	do
		if [[ "$XG_t" == "$1" ]]; then
			return 0
		fi
	done
	XG_ALREADYCHECKED+=( "$1" )
	# Search check function
	XG_res=0
	for XG_t in "${XG_TARGETSCHECK[@]}"
	do
		if [[ "$XG_target" == "$XG_t" ]]; then
			XG_res=1
			break
		fi
	done
	# If target have check function
	if [[ $XG_res -eq 1 ]]; then
		eval "XG_check_$XG_target"
		if [[ $? -eq 1 ]]; then
			for XG_t in ${XG_TARGETDEPENDS[$1]};
			do
				XG_find_extension $XG_t
				XG_addtarget "$XG_out"_"$XG_t"
			done
		else
			return 0
		fi
	# If this target exist
	else
		"XG_$XG_extension"_check "$1"
		if [[ $? -eq 1 ]]; then
			for XG_t in ${XG_TARGETDEPENDS[$1]};
			do
				XG_find_extension $XG_t
				XG_addtarget "$XG_out"_"$XG_t"
			done
		else
			return 0
		fi
	# If error
	fi
	XG_DO+=( $1 )
	return 0
}

# Function for check completed target
function XG_target_check()
{
	return 1
}

# Function for do target
function XG_target_action()
{
	IFS=""
	eval "${XG_TARGETS["$1"]}"
	IFS=" "
}

function XG_find_extension()
{
	XG_out=""
	if [ -z "$1" ]; then
		return 1
	fi
	for XG_e in ${XG_EXTENSIONS[@]} target
	do
		if [[ -n "${XG_TARGETS[""$XG_e""_$1]}" ]]; then
			XG_out="$XG_e"
			return 0
		fi
	done
	return 1
}

# Variables
# Text factoring
XG_C_END="\033[0m"
XG_C_GREEN="\033[32m"
XG_C_YELLOW="\033[33m"
XG_C_RED="\033[31m"
XG_C_BOLD="\033[1m"
XG_C_OK="$XG_C_GREEN[OK]:$XG_C_END"
XG_C_WARNING="$XG_C_YELLOW[Warning]:$XG_C_END"
XG_C_WAIT="$XG_C_YELLOW[Wait...]:$XG_C_END"
XG_C_ERROR="$XG_C_RED[ERROR]:$XG_C_END"
# Declare program arrays
# Assocaitive arrays
declare -A XG_TARGETS
declare -A XG_TARGETDEPENDS
# Usual arrays
declare -a XG_EXTENSIONS
declare -a XG_DO
declare -a XG_ALREADYCHECKED
declare -a XG_EXTENSIONSFILES
declare -a XG_TARGETSCHECK
declare -a XG_TARGETSUSER
declare -a XG_USERTARGETS
# Declare arrays with user info
declare -a XG_USERVARIABLES
# Define variables
XG_cur_extension=""
XG_cur_target=""
XG_func=""
XG_cur_check=0
XG_cur_action=0
XG_cur_command=0
XG_EXTENSIONSFILES=( "./extensions/package.xge" "./extensions/pip3.xge" ) # Standart extensions

# Identify distribution of Linux
XG_getDistributionName
XG_DISTRIBUTION=${XG_out,,}
if [[ $XG_DISTRIBUTION=="ubuntu" || $XG_DISTRIBUTION=="debian" || $XG_DISTRIBUTION=="linuxmint" ]]; then
	XG_USERCHANGE="su %%%"
fi

# Main program
# Parsing arguments
for XG_arg in ${@:2}
do
	# Parsing additionaly arguments
	if [[ "$XG_arg" =~ ^--ext=(.+)$ ]]; then
		XG_EXTENSIONSFILES+=( "${BASH_REMATCH[1]}" )
	# Parsing any variables set
	elif [[ "$XG_arg" =~ ^--([[:alnum:]]+)=(.+)$ ]]; then
		XG_USERVARIABLES+=( "${BASH_REMATCH[1]}"="\"${BASH_REMATCH[2]}\"" )
	elif [[ "$XG_arg" =~ ^[[:graph:]]+$ ]]; then
		XG_USERTARGETS+=( "${BASH_REMATCH[0]}" )
	fi
done


# Check extensions files
for XG_ef in ${XG_EXTENSIONSFILES[@]}
do
	if [ ! -f "$XG_ef" ]; then
		echo -e $XG_C_ERROR$XG_C_BOLD$XG_C_RED"Нет файла расширения \"$XG_ef\""$XG_C_END
		exit
	fi
done
# Parsing extensions files
for XG_ef in ${XG_EXTENSIONSFILES[@]}
do
	XG_cur_extension=""
	XG_string_number=1
	IFS="
"
	for XG_line in $(cat $XG_ef)
	do
		# Extension name parsing
		if [[ "$XG_line" =~ ^name[[:blank:]]+([[:alpha:]][[:alnum:]]*)[[:blank:]]*$ ]]; then
			# Check if extension name in file declare more than one time
			if [ -n "$XG_cur_extension" ]; then
				echo -e $XG_C_ERROR$XG_C_RED$XG_C_BOLD"Файл \"$XG_ef\":\nСтрока: $XG_string_number\nПовторное указание имени расширения"$XG_C_END
				exit
			fi
			# Check if previous string is a bash function
			if [[ "$XG_cur_command" -eq 1 ]]; then
				XG_func+=" #"
				eval "$XG_func"
				XG_func=""
				XG_cur_command=0
			fi
			# Check if file have equal extension name with previews extension
			IFS=" "
			for XG_ext in ${XG_EXTENSIONS[@]}
			do
				if [[ "$XG_ext" == "${BASH_REMATCH[1]}" ]]; then
					echo =e $XG_C_ERROR$XG_C_RED$XG_C_BOLD"Файл \"$XG_ef\":\nСтрока: $XG_string_number\nДанное расширение уже добавлено"$XG_C_END
					exit
				fi
			done
			IFS="
"
			# Add extension name
			XG_cur_extension="${BASH_REMATCH[1]}"
			XG_EXTENSIONS+=( "$XG_cur_extension" )
		# Extension check function parsing
		elif [[ "$XG_line" =~ ^check[[:blank:]]*$ ]]; then
			# Check if extension name doesn't declare
			if [ -z "$XG_cur_extension" ]; then
				echo -e $XG_C_ERROR$XG_C_RED$XG_C_BOLD"Файл \"$XG_ef\":\nСтрока: $XG_string_number\nНеизвестное имя расширения (отсутствует директива \"name ...\")" $XG_C_END
				exit
			fi
			# Check if previous string is a bash function
			if [[ "$XG_cur_command" -eq 1 ]]; then
				XG_func+=" #"
				eval "$XG_func"
				XG_func=""
				XG_cur_command=0
			fi
			XG_func="function XG_""$XG_cur_extension""_check(){"
			XG_cur_check=1
		elif [[ "$XG_line" == "endcheck" && "$XG_cur_check" -eq 1 ]]; then
			XG_func+="}"
			eval "$XG_func"
			XG_func=""
			XG_cur_check=0
		# Extension action function parsing
		elif [[ "$XG_line" =~ ^action[[:alpha:]]*$ ]]; then
			# Check if extension name doesn't declare
			if [ -z "$XG_cur_extension" ]; then
				echo -e $XG_C_ERROR$XG_C_RED$XG_C_BOLD"Файл \"$XG_ef\":\nСтрока: $XG_string_number\nНеизвестное имя расширения (отсутствует директива \"name ...\"" $XG_C_END
				exit
			fi
			# Check if previous string is a bash function
			if [[ "$XG_cur_command" -eq 1 ]]; then
				XG_func+=" #"
				eval "$XG_func"
				XG_func=""
				XG_cur_command=0
			fi
			XG_func="function XG_""$XG_cur_extension""_action(){"
			XG_cur_action=1
		elif [[ "$XG_line" == "endaction" && "$XG_cur_action" -eq 1 ]]; then
			XG_func+="}"
			eval "$XG_func"
			XG_func=""
			XG_cur_action=0
		# If function is writting
		elif [[ $XG_cur_check -eq 1 || $XG_cur_action -eq 1 || $XG_cur_command -eq 1 ]]; then
			XG_func+=$(echo "$XG_line" | sed "s/\t+//g")"
"
		# Another strings
		else
			XG_cur_command=1
			XG_func="$line
"
		fi
		XG_string_number=$(expr $XG_string_number + 1)
	done
	IFS=" "
done
# Check if previous string is a bash function
if [[ "$XG_cur_command" -eq 1 ]]; then
	XG_func+=" #"
	eval "$XG_func"
	XG_func=""
	XG_cur_command=0
fi
# Check definition function
for XG_e in ${XG_EXTENSIONS[@]}
do
	if [[ -z $(type "XG_$XG_e""_action") ]]; then
		echo -e $XG_C_ERROR$XG_C_RED$XG_C_BOLD"В расширении $XG_e отсутствует функция выполнения цели"$XG_C_END
		exit
	fi
	if [[ -z $(type "XG_$XG_e""_check") ]]; then
		echo -e $XG_C_ERROR$XG_C_RED$XG_C_BOLD"В расширении $XG_e отсутствует функция проверки цели"$XG_C_END
		exit
	fi
done



# Check existing build file
if [ ! -f "$1" ]; then
	echo -e $XG_C_ERROR$XG_C_RED$XG_C_BOLD"Файл сборки '$1' не существует"$XG_C_END
	exit
fi
# Parsing build file
XG_cur_action=0
XG_cur_check=0
XG_cur_command=0
XG_cur_extension=""
XG_cur_target=""
XG_func=""
XG_cur_user=$USER
XG_extensionslist=$(echo "${XG_EXTENSIONS[@]} target" | sed "s/ /|/g")
XG_file=$(cat "$1" | sed -e "/^$/d" -e "/^[[:blank:]]*$/d" -e "/^[[:blank:]]*#.*$/d")
IFS="
"
for XG_line in $XG_file
do
	# Targets parsing
	if [[ "$XG_line" =~ ^@([[:graph:]]+)[[:blank:]]*$ ]]; then
		XG_cur_user=${BASH_REMATCH[1]}
	elif [[ "$XG_line" =~ ^($XG_extensionslist)[[:blank:]]+([[:graph:]]+):([[:print:]]*)$ ]]; then
		# Search for duplicate
		XG_find_extension ${BASH_REMATCH[2]}
		if [[ $? -eq 0 ]]; then
			echo -e $XG_C_ERROR$XG_C_RED$XG_C_BOLD"Цель ${BASH_REMATCH[2]} уже была объявлена"$XG_C_END
			exit
		fi
		# If previous strings are target
		if [[ -n "$XG_cur_target" ]]; then
			if [[ -z "$XG_func" ]]; then
				XG_func="#"
			fi
			XG_TARGETS[$XG_cur_target]="$XG_func"
			XG_TARGETSUSER[$XG_cur_targer]="$XG_cur_user"
			XG_cur_user=$USER
			XG_func=""
			XG_cur_target=""
		fi
		XG_TARGETDEPENDS[${BASH_REMATCH[1]}_${BASH_REMATCH[2]}]=${BASH_REMATCH[3]}
		XG_cur_target=${BASH_REMATCH[1]}_${BASH_REMATCH[2]}
	# Targets check functions parsing
	elif [[ "$XG_line" =~ ^check[[:blank:]]+([[:graph:]]+)\(\)[[:blank:]]*$ ]]; then
		if [[ -n "$XG_cur_target" ]]; then
			if [[ -z "$XG_func" ]]; then
				XG_func="#"
			fi
			XG_TARGETS[$XG_cur_target]="$XG_func"
			XG_TARGETSUSER[$XG_cur_targer]="$XG_cur_user"
			XG_cur_user=$USER
			XG_func=""
			XG_cur_target=""
		fi
		XG_TARGETSCHECK+=( ${BASH_REMATCH[1]} )
		XG_func="function XG_check_${BASH_REMATCH[1]}(){"
		XG_cur_check=1
	elif [[ "$XG_line" == "endcheck" ]]; then
		XG_func+="}"
		eval "$XG_func"
		XG_func=""
		XG_cur_check=0
	# Add strings for target or for check function
	elif [[ $XG_cur_check -eq 1 || -n $XG_cur_target ]]; then
		XG_func+=$(echo $XG_line | sed "s/[\	]+//g")"
"
	# Another strings
	else
		eval "$XG_line"
	fi
done
IFS=" "
# If previous strings are target 
if [[ -n "$XG_cur_target" ]]; then
	if [[ -z "$XG_func" ]]; then
		XG_func="#"
	fi
	XG_TARGETS[$XG_cur_target]="$XG_func"
	XG_TARGETSUSER[$XG_cur_targer]="$XG_cur_user"
	XG_cur_user=$USER
	XG_func=""
	XG_cur_target=""
fi

# Add targets to list for execute
for XG_t in ${XG_USERTARGETS[@]}
do
	XG_find_extension $XG_t
	if [[ $? -eq 1 ]]; then
		echo -e $XG_C_ERROR$XG_C_RED$XG_C_BOLD"Не найдена цель '$XG_t'"$XG_C_END
		exit
	else
		XG_addtarget "$XG_out"_"$XG_t"
	fi
done



# Add user variables
for XG_t in ${XG_USERVARIABLES[@]}
do
	eval "$XG_t"
done


# Do targets
for XG_t in ${XG_DO[@]}
do	
	# Check target argument
	if [[ "$XG_t" =~ ([[:alnum:]]+)_([[:alnum:]]+)$ ]]; then
		XG_extension=${BASH_REMATCH[1]}
		XG_target=${BASH_REMATCH[2]}
	fi
	echo -e $XG_C_WAIT$XG_C_BOLD"Выполняется цель '$XG_target'"$XG_C_END
    if [[ -n ${XG_TARGETSUSER[$XG_t]} ]]; then
		XG_"$XG_extension"_action $XG_t
	else
        XG_"$XG_extension"_action $XG_t
    fi
done
